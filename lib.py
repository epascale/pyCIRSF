import numpy as np
from astropy.io import ascii
from astropy.table import hstack, Table
import astropy.coordinates as coord
import astropy.units as u
import scipy.interpolate
from photutils import CircularAperture, aperture_photometry, \
    CircularAnnulus, RectangularAnnulus
from openpyxl import load_workbook
import sys, os


def pycirsf_error(error_msg):
    sys.stderr.write("Error code: {:s}\n".format(error_msg))
    sys.exit(0)

def get_frames_flags(fname, date, object_name):
    wb = load_workbook(fname)
    
    ws = wb[date]
    
    ws_frames = np.array([c.value for c in ws.columns[ 0]][1:])
    ws_objects =         [c.value for c in ws.columns[ 1]][1:]
    ws_itimes = np.array([c.value for c in ws.columns[ 2]][1:])
    ws_ra_off = np.array([c.value for c in ws.columns[ 3]][1:])
    ws_de_off = np.array([c.value for c in ws.columns[ 4]][1:])
    ws_flags  = np.array([c.value for c in ws.columns[14]][1:])
    
    list_ = []
    for i in xrange(len(ws_objects)):
        if ws_objects[i] == object_name and np.int(ws_flags[i]) == 0:
            list_.append([np.int(ws_frames[i]), ws_itimes[i], ws_ra_off[i], ws_de_off[i] ])
    
    return Table([l for l in zip(*list_)], names=('Frame', 'ITIME', 'RA_OFF', 'DEC_OFF'))
            
        
    
    
    
 
def multiplicative_mask(mask, flag_mask = 0x1|0x4, nanfill=None):
    ''' 
    Create a mask array containing 0 (bad pixels) and 1 (good pixels)
    from the raw mask array. 
    Mask values are specidied in the mask header and currently are
    0x1: Array central region
    0x2: |QE-1| > 3sigma
    0x4: |QE-1| > 5sigma
    0x8: |QE-1| > 10sigma
    
    '''
    if not np.issubdtype(mask.dtype, np.integer):
        pycirsf_error('multiplicative_mask: mask dtype should be int')
    
    mask_ = np.bitwise_xor(np.bitwise_and(mask, flag_mask), flag_mask)/flag_mask
    
    if nanfill:
      idx = np.where(mask_ == 0)
      mask_ = mask_.astype(np.float32)
      mask_[idx] = np.nan
      
    return mask_
    
def masked_array(ima, mask, flag_mask = 0x1|0x4):
    ''' 
    Create a masked array from the raw image and raw mask array.
    See pyCRSF.lib.multiplicative_mask for availabe mask flags, or mask fits header

    '''

    if not np.issubdtype(mask.dtype, np.integer):
        pycirsf_error('multiplicative_mask: mask dtype should be int')
    
    mask_ = np.bitwise_and(mask, flag_mask).astype(np.bool)
    ima *= np.logical_not(mask_)
    return np.ma.masked_array(ima, mask_)

    

def remove_bias(ima, mask, flag_mask = 0x1|0x4, region='quadrant', zero_off=False):
    '''
    Remove bias from image by estimating the median of the array 
    the region-of-interest specified by 'region'.
    
    Parameters
    ----------
    
    ima  : array_like
           input image to be de-biased
    mask : array_like
           mask to be used
    flag : scalar
           flag value to apply in mask. Mask pixels that match flag in the bitwise or are excluded.
    region : string
           if 'quadrant' is specified, the array is divided in 4 quadrants
           and a median value per quadrant is estimated.
           If 'section' is specified, the array is divided into two sections (left and write
           along axis 0) and a median is estimated in each of the two sections.
    zero_off: bool
           if False (default) each section is scaled such that its DC-level metches the average 
           of medians estimated. If True, the median in each quadrant is subtracted from each quadrant.
    
    '''
    
    dy, dx = ima.shape
    
    maskm = multiplicative_mask(mask, flag_mask=flag_mask)
    
    m = []
    if region == 'quadrant':
        pass
    
    elif region == 'section':
        i = 1
        for j in [0, 1]:
           idx = np.where(maskm[..., j*dx/2:(j+1)*dx/2])
           m.append(np.median(ima[..., j*dx/2:(j+1)*dx/2][idx]))
        
        for j in [0, 1]:
            ima[..., j*dx/2:(j+1)*dx/2] = ima[..., j*dx/2:(j+1)*dx/2] - m[i]
    
    return ima
           

def read_reference_cat(fname=None, Jmag_lim=10.6):
    '''
    Read catalogue of star locations generated by starlink, 
    and retain stars brighter than J_maglim
    
    '''
    if not fname: pycirsf_error('Catalog file name not defined')
        
    cat = ascii.read(fname, header_start=14, data_start=16)
    cat.sort('Jmag')
    
    idx = np.where(cat['Jmag'] < Jmag_lim)
    cat = cat[idx]
    
    return cat, coord.Angle(cat['RAJ2000'], u.hour), \
        coord.Angle(cat['DEJ2000'], u.degree)

def stacking(ima, xc, yc, N = 31, remove_background=True):
    '''
    Stack the input image at locations xc, yc. 
    The stack image has shape NxN. 
    If remove_background is true, a background estimated in a rectangular annulus and removed.
    
    '''
    
    ima_ = ima.copy()
    idx = np.where(np.isnan(ima_))
    ima_[idx] = 0.0

    stamp = np.zeros( (N, N) )
    
    x = np.arange(ima_.shape[1])
    y = np.arange(ima_.shape[0])
    
    f = scipy.interpolate.interp2d(x, y, ima_, kind='cubic', fill_value=0.0)
    new_x = np.arange(N) - N//2
    new_y = np.arange(N) - N//2
    for xx, yy in zip(xc, yc):
        stamp += f(new_x+xx, new_y+yy)
    
    if remove_background:
        anulus_apertures = RectangularAnnulus(
            (stamp.shape[1]/2, stamp.shape[0]/2), 
            w_out=stamp.shape[0]/2, h_out=stamp.shape[1]/2,
            w_in=0.5*stamp.shape[0]/2, theta=0.0)
        
        bkg = aperture_photometry(stamp, anulus_apertures)
        bkg['aperture_sum'] /= anulus_apertures.area()
        stamp -= bkg['aperture_sum']
        
    
    stamp /= stamp.sum()
    
    light_baricenter_x = (stamp*np.arange(stamp.shape[1])).sum()
    light_baricenter_y = (stamp.transpose()*np.arange(stamp.shape[0])).sum()
    
    return stamp, light_baricenter_x, light_baricenter_y

def photom(ima, pos, radius, r_in=False, r_out=False):
    '''
    Aperture photometry in an aperture located at pixel coordinates 
    pos = ( (x0, y0), (x1, y1), ... ) with a radius=radius.
    When r_in and r_out are given, background is estimated in CircularAnnulus and subtracted.

    '''
    apertures = CircularAperture(pos, r = radius)
    
    
    ap = aperture_photometry(ima, apertures)
    
    bkg = False
    if (r_in and r_out):
        anulus_apertures = CircularAnnulus(pos, r_in=r_in, r_out=r_out)
        bkg = aperture_photometry(ima, anulus_apertures)
        bkg.rename_column('aperture_sum', 'background')
        bkg['background'] *= apertures.area()/anulus_apertures.area()
        ap.add_column(bkg['background'])
        flux = ap['aperture_sum']-ap['background']
        flux.name = 'flux'
        ap.add_column(flux)
        
    return ap['flux'], ap



class Formatter(object):
    def __init__(self, im):
        self.im = im
    def __call__(self, x, y):
        z = self.im.get_array()[int(y), int(x)]
        return 'x={:.01f}, y={:.01f}, z={:.02f}'.format(x, y, z)



if __name__ == "__main__":
    from astropy.io import fits
    import matplotlib.pyplot as plt
    
    
    mask = fits.open(os.path.expanduser('~/IRSF/calibration/kmask_160128.fits'))[0].data
    flat = fits.open(os.path.expanduser('~/IRSF/calibration/kflat_160128.fits'))[0].data
    #flat = fits.open(os.path.expanduser('~/IRSF/pyIRSF-2.2.1/lib/kcflat.fits'))[0].data
    ima  = fits.open(os.path.expanduser('~/IRSF/data/160128/rawdata/k160128_0100.fits.fz'))[1].data
    
    maskm = multiplicative_mask(mask, nanfill=False)
    ima = maskm * ima / flat 
    #ima = remove_bias(ima, mask, flag_mask = 0x1|0x8, region='section')
    
    plt.ion()
    fig, (ax0, ax1) = plt.subplots(ncols=2, num=1)
    im0 = ax0.imshow(maskm, interpolation='None')
    ax0.format_coord = Formatter(im0)
    vlo, vhi = np.percentile(ima, (5, 99.99))
    im1 = ax1.imshow(ima, vmin=vlo, vmax=vhi, interpolation='None')
    ax1.format_coord = Formatter(im0)
    
    pass